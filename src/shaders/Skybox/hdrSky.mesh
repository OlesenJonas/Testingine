#include "../includes/Bindless/Setup.hlsl"
#include "../includes/GPUScene/Setup.hlsl"

struct VertexOut
{
    float4 posOut : SV_POSITION;
    [[vk::location(0)]]	float3 localPos : POSITIONT;
    [[vk::location(1)]] int instanceIndex : INSTANCE_INDEX;
//     uint   MeshletIndex : COLOR0;
};

[NumThreads(128, 1, 1)]
[OutputTopology("triangle")]
void main(
    uint threadID : SV_GroupThreadID,
    uint groupID : SV_GroupID,
    out indices uint3 tris[124],
    out vertices VertexOut verts[64]
    // out primitives PrimitiveAttributes prims[MAX_OUTPUT_PRIMITIVES]
)
{
    //needs defines instead of storing buffers in vars since broken in mesh shaders atm :/ (see Access.hlsl)

    const InstanceInfo instanceInfo = getInstanceInfo(pushConstants.indexInInstanceBuffer);
    MeshData meshData = getMeshData(instanceInfo);

    const ConstantBuffer<RenderPassData> renderPassData = getRenderPassData();
    #define vertexPositions StrucBuffFromHandle(float3, meshData.positionBuffer)
    const float3 vertPos = vertexPositions[0];
    #define vertexAttributes ByteBuffFromHandle(meshData.attributesBuffer)

    MeshletDescriptor m = StrucBuffFromHandle(MeshletDescriptor, meshData.meshletDescriptors)[groupID];
    #define meshletUniqueVertexIndices StrucBuffFromHandle(uint, meshData.meshletUniqueVertexIndices)
    #define meshletPrimitiveIndices StrucBuffFromHandle(uint, meshData.meshletPrimitiveIndices)

    SetMeshOutputCounts(m.vertexCount, m.primCount);

    if (threadID < m.primCount)
    {
        const uint primBaseU8Index = m.primBegin + threadID*3u;
        uint word = meshletPrimitiveIndices[primBaseU8Index >> 2u];
        const uint bitStartInWord0 = (primBaseU8Index << 3u) & 0b11111u;
        const uint bitsInWord0 = 32u - bitStartInWord0;
        // move relevant bytes into lowest bits
        word >>= bitStartInWord0;
        // mask unused bits
        word &= ~(0xFFFFFFFFu << bitsInWord0);
        // move relevant bytes from next word into upper bits
        word |= meshletPrimitiveIndices[(primBaseU8Index + 2) >> 2u] << bitsInWord0;

        tris[threadID] = uint3(
            (word)          & 0xFFu,
            (word >> 8u)    & 0xFFu,
            (word >> 16u)   & 0xFFu
        );
    }

    if (threadID < m.vertexCount)
    {
        uint vertexIndex = meshletUniqueVertexIndices[m.vertexBegin + threadID];

        VertexOut vertex = (VertexOut)0;
        vertex.instanceIndex = pushConstants.indexInInstanceBuffer;

        const float3 vertPos = vertexPositions[vertexIndex];
        vertex.localPos = vertPos;
        //todo: dont just scale up by some large number, instead make forcing depth to 1.0 work!
        float4 worldPos = float4(500*vertPos,1.0);

        const float4x4 projMatrix = renderPassData.drawCam.proj;
        const float4x4 viewMatrix = renderPassData.drawCam.view;
        //remove translation component from view matrix
        const float4x4 viewMatrixNoTranslate = float4x4(
            viewMatrix[0].xyz,0.0,
            viewMatrix[1].xyz,0.0,
            viewMatrix[2].xyz,0.0,
            viewMatrix[3].xyz,1.0
        );
        vertex.posOut = mul(projMatrix, mul(viewMatrixNoTranslate, worldPos));

        verts[threadID] = vertex;
    }
}