#include "../includes/Bindless/Setup.hlsl"
#include "../includes/GPUScene/Setup.hlsl"

struct VertexOut
{
    float4 posOut : SV_POSITION;
    [[vk::location(0)]]	float3 localPos : POSITIONT;
    [[vk::location(1)]] int instanceIndex : INSTANCE_INDEX;
//     uint   MeshletIndex : COLOR0;
};

[NumThreads(128, 1, 1)]
[OutputTopology("triangle")]
void main(
    uint threadID : SV_GroupThreadID,
    uint groupID : SV_GroupID,
    out indices uint3 tris[126],
    out vertices VertexOut verts[64]
    // out primitives PrimitiveAttributes prims[MAX_OUTPUT_PRIMITIVES]
)
{
    //needs defines instead of storing buffers in vars since broken in mesh shaders atm :/ (see Access.hlsl)

    const InstanceInfo instanceInfo = getInstanceInfo(pushConstants.indexInInstanceBuffer);
    MeshData meshData = getMeshData(instanceInfo);

    const ConstantBuffer<RenderPassData> renderPassData = getRenderPassData();
    #define vertexPositions StrucBuffFromHandle(float3, meshData.positionBuffer)
    const float3 vertPos = vertexPositions[0];
    #define vertexAttributes ByteBuffFromHandle(meshData.attributesBuffer)

    MeshletDescriptor m = StrucBuffFromHandle(MeshletDescriptor, meshData.meshletDescriptors)[groupID];
    #define meshletVertexIndices StrucBuffFromHandle(uint, meshData.meshletVertexIndices)
    #define meshletPrimitiveIndices StrucBuffFromHandle(uint, meshData.meshletPrimitiveIndices)

    SetMeshOutputCounts(m.vertexCount, m.primCount);

    if (threadID < m.primCount)
    {
        uint3 primIndices = 0;
        primIndices[0] = meshletPrimitiveIndices[m.primBegin + threadID*3 + 0];
        primIndices[1] = meshletPrimitiveIndices[m.primBegin + threadID*3 + 1];
        primIndices[2] = meshletPrimitiveIndices[m.primBegin + threadID*3 + 2];
        tris[threadID] = primIndices;
    }

    if (threadID < m.vertexCount)
    {
        uint vertexIndex = meshletVertexIndices[m.vertexBegin + threadID];

        VertexOut vertex = (VertexOut)0;
        vertex.instanceIndex = pushConstants.indexInInstanceBuffer;

        const float3 vertPos = vertexPositions[vertexIndex];
        vertex.localPos = vertPos;
        //todo: dont just scale up by some large number, instead make forcing depth to 1.0 work!
        float4 worldPos = float4(500*vertPos,1.0);

        const float4x4 projMatrix = renderPassData.proj;
        const float4x4 viewMatrix = renderPassData.view;
        //remove translation component from view matrix
        const float4x4 viewMatrixNoTranslate = float4x4(
            viewMatrix[0].xyz,0.0,
            viewMatrix[1].xyz,0.0,
            viewMatrix[2].xyz,0.0,
            viewMatrix[3].xyz,1.0
        );
        vertex.posOut = mul(projMatrix, mul(viewMatrixNoTranslate, worldPos));

        verts[threadID] = vertex;
    }
}