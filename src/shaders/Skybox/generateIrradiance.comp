#include "../Bindless/Setup.hlsl"

DefineShaderInputs(
    Handle< TextureCube<float4> > sourceTex;
    Handle< SamplerState > sourceSampler;
    Handle< RWTexture2DArray<float4> > irradianceTex;
);

#define PI 3.141592653589793238462643383279502884197169399375105820974944
#define TWO_PI 6.2831853071795864769252867665590
#define HALF_PI 1.5707963267948966192313216916398

[numthreads(8, 8, 1)]
void main(
    uint3 GlobalInvocationID : SV_DispatchThreadID,
    uint3 LocalInvocationID : SV_GroupThreadID
)
{
    int3 id = GlobalInvocationID;

    TextureCube<float4> sourceTex = shaderInputs.sourceTex.get();
    SamplerState sourceSampler = shaderInputs.sourceSampler.get();

    //TODO: getLocalPos(tex, id) helper function?
    RWTexture2DArray<float4> targetTex = shaderInputs.irradianceTex.get();
    int3 size;
    targetTex.GetDimensions(size.x, size.y, size.z);
    float2 uv = float2(id.xy + 0.5) / size.xy;
    uv.y = 1.0 - uv.y;
    uv = 2.0 * uv - 1.0;

    int2 inputResolution;
    sourceTex.GetDimensions(inputResolution.x,inputResolution.y);

    float3 localPos;
    if(id.z == 0)
        localPos = float3(1.0, uv.y, -uv.x); // pos x
    else if(id.z == 1)
        localPos = float3(-1.0, uv.y, uv.x); // neg x
    else if(id.z == 2)
        localPos = float3(uv.x, 1.0, -uv.y); // pos y
    else if(id.z == 3)
        localPos = float3(uv.x, -1.0, uv.y); // neg y
    else if(id.z == 4)
        localPos = float3(uv.x, uv.y, 1.0); // pos z
    else if(id.z == 5)
        localPos = float3(-uv.x, uv.y, -1.0); // neg z

    float3 N = normalize(localPos);

    float3 up = abs(N.z) < 0.999 ? float3(0,0,1) : float3(1,0,0);
    const float3 right = normalize(cross(up, N));
    up = cross(N, right); 

    float3 color = 0.0;
    uint sampleCount = 0u;
    float deltaPhi = TWO_PI / 1000.0;
    float deltaTheta = HALF_PI / 500.0;
    for (float phi = 0.0; phi < TWO_PI; phi += deltaPhi)
    {
        for (float theta = 0.0; theta < HALF_PI; theta += deltaTheta)
        {
            // Spherical to World Space in two steps...
            float3 tempVec = cos(phi) * right + sin(phi) * up;
            float3 sampleVector = cos(theta) * N + sin(theta) * tempVec;
            // color += textureCubeLod(s_source, sampleVector, 0).rgb * cos(theta) * sin(theta);
            color += sourceTex.SampleLevel(sourceSampler, sampleVector, 0).rgb * cos(theta) * sin(theta);
            sampleCount++;
        }
    }

    color = PI*color/float(sampleCount);

    // targetTex[id] = irradiance;
    targetTex[id] = float4(color, 1.0);
}