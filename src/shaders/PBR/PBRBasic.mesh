#define NO_DEFAULT_PUSH_CONSTANTS
#include "../includes/Bindless/Setup.hlsl"
#include "../includes/GPUScene/Setup.hlsl"

DefinePushConstants(
    ResrcHandle< ConstantBuffer<RenderPassData> > renderInfoBuffer;
    ResrcHandle< StructuredBuffer<uint> > perBatchOffsetBuffer;
    ResrcHandle< StructuredBuffer<InstanceInfo> > sortedInstanceBuffer;
    uint batchIndex;
);

struct Payload
{
    uint batchStartInInstanceBuffer;
};

/*
    Not sure if semantic names are needed when compiling only to spirv
*/
struct VertexOut
{
    float4 posOut : SV_POSITION;
    [[vk::location(0)]]	float3 vPositionWS : POSITIONT;
    [[vk::location(1)]] float3 vNormalWS : NORMAL0;
    [[vk::location(2)]] float3 vColor : COLOR0;  
    [[vk::location(3)]] float2 vTexCoord0 : TEXCOORD0;
    [[vk::location(4)]] float2 vTexCoord1 : TEXCOORD1;
    [[vk::location(5)]] float2 vTexCoord2 : TEXCOORD2;
    [[vk::location(6)]] int2 instanceAndMeshletIndex : BASE_INSTANCE;
};

#define MAX_VERTS 64
#define MAX_TRIS 124
#define GROUP_SIZE 32

[NumThreads(GROUP_SIZE, 1, 1)]
[OutputTopology("triangle")]
void main(
    uint threadID : SV_GroupThreadID,
    uint2 groupID : SV_GroupID,
    in payload Payload payload,
    out vertices VertexOut verts[MAX_VERTS],
    out indices uint3 tris[MAX_TRIS]
    // out primitives PrimitiveAttributes prims[MAX_OUTPUT_PRIMITIVES]
)
{
    #define instanceBuffer StrucBuffFromHandle(InstanceInfo, pushConstants.sortedInstanceBuffer)
    #define batchOffsetBuffer StrucBuffFromHandle(uint, pushConstants.perBatchOffsetBuffer)
    uint instanceIndex = payload.batchStartInInstanceBuffer + groupID.y;
    const InstanceInfo instanceInfo = instanceBuffer[instanceIndex];
    const MeshData meshData = getMeshData(instanceInfo);

    #define vertexPositions StrucBuffFromHandle(float3, meshData.positionBuffer)
    const float3 vertPos = vertexPositions[0];
    #define vertexAttributes ByteBuffFromHandle(meshData.attributesBuffer)

    MeshletDescriptor m = StrucBuffFromHandle(MeshletDescriptor, meshData.meshletDescriptors)[groupID.x];
    #define meshletUniqueVertexIndices StrucBuffFromHandle(uint, meshData.meshletUniqueVertexIndices)
    #define meshletPrimitiveIndices StrucBuffFromHandle(uint, meshData.meshletPrimitiveIndices)

    SetMeshOutputCounts(m.vertexCount, m.primCount);

    const uint primLoops = (MAX_TRIS + GROUP_SIZE - 1) / GROUP_SIZE;
    for (uint loop = 0; loop < primLoops; loop++)
    {
        uint primIndex = threadID + loop*GROUP_SIZE;
        //instead of branching clamp to max for better loads (see nvidia blogs, not tested if actually better)
        primIndex = min(primIndex, m.primCount-1);
        
        const uint primBaseU8Index = m.primBegin + primIndex*3u;
        uint word = meshletPrimitiveIndices[primBaseU8Index >> 2u];
        const uint bitStartInWord0 = (primBaseU8Index << 3u) & 0b11111u;
        const uint bitsInWord0 = 32u - bitStartInWord0;
        // move relevant bytes into lowest bits
        word >>= bitStartInWord0;
        // mask unused bits
        word &= ~(0xFFFFFFFFu << bitsInWord0);
        // move relevant bytes from next word into upper bits
        word |= meshletPrimitiveIndices[(primBaseU8Index + 2) >> 2u] << bitsInWord0;

        tris[primIndex] = uint3(
            (word)          & 0xFFu,
            (word >> 8u)    & 0xFFu,
            (word >> 16u)   & 0xFFu
        );
    }

    ConstantBuffer<RenderPassData> renderPassData = pushConstants.renderInfoBuffer.get();

    const uint vertexLoops = (MAX_VERTS + GROUP_SIZE - 1) / GROUP_SIZE;
    for (uint loop = 0; loop < vertexLoops; loop++)
    {
        uint threadOffset = threadID + loop*GROUP_SIZE;
        uint vertexIndex = meshletUniqueVertexIndices[m.vertexBegin + threadOffset];

        const float4x4 projViewMatrix = renderPassData.projView;
        // const float4x4 projViewMatrix = g_ConstantBuffer_RenderPassData[shaderInputs.renderPassData.resourceIndex].projView;
        //todo: test mul-ing here already, like in GLSL version
        // const mat4 transformMatrix = getBuffer(RenderPassData, bindlessIndices.renderPassDataBuffer).projView * modelMatrix;

        VertexOut vsOut = (VertexOut)0;
        vsOut.instanceAndMeshletIndex.x = instanceIndex;
        vsOut.instanceAndMeshletIndex.y = groupID.x;

        const float3 vertPos = vertexPositions[vertexIndex];
        float4 worldPos = mul(instanceInfo.transform, float4(vertPos,1.0));

        vsOut.vPositionWS = worldPos.xyz;
        vsOut.posOut = mul(projViewMatrix, worldPos);

        vsOut.vColor = vertexAttributes.Load<float3>(vertexIndex * meshData.attribStride() + meshData.colorOffset());
        vsOut.vTexCoord0 = vertexAttributes.Load<float2>(vertexIndex * meshData.attribStride() + meshData.uvOffset(0));
        vsOut.vTexCoord1 = vertexAttributes.Load<float2>(vertexIndex * meshData.attribStride() + meshData.uvOffset(1));
        vsOut.vTexCoord2 = vertexAttributes.Load<float2>(vertexIndex * meshData.attribStride() + meshData.uvOffset(2));

        const float3x3 invTranspModelMatrix3 = (float3x3)(instanceInfo.invTranspTransform);
        const float3 vNormal = vertexAttributes.Load<float3>(vertexIndex * meshData.attribStride());
        vsOut.vNormalWS = normalize(mul(invTranspModelMatrix3, vNormal));

        verts[threadOffset] = vsOut;
    }
}