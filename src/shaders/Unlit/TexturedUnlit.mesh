#include "../includes/Bindless/Setup.hlsl"
#include "../includes/GPUScene/Access.hlsl"
#include "../includes/VertexAttributes.hlsl"
#include "../includes/CommonTypes.hlsl"

/*
    Not sure if semantic names are needed when compiling only to spirv
*/
struct VertexOut
{
    float4 posOut : SV_POSITION;
    [[vk::location(0)]] float2 vTexCoord : TEXCOORD0;
    [[vk::location(1)]] int instanceIndex : INSTANCE_INDEX;
};

[NumThreads(128, 1, 1)]
[OutputTopology("triangle")]
void main(
    uint threadID : SV_GroupThreadID,
    uint groupID : SV_GroupID,
    out indices uint3 tris[124],
    out vertices VertexOut verts[64]
    // out primitives PrimitiveAttributes prims[MAX_OUTPUT_PRIMITIVES]
)
{
    const InstanceInfo instanceInfo = getInstanceInfo(pushConstants.indexInInstanceBuffer);
    const MeshData meshData = getMeshData(instanceInfo);

    #define vertexPositions StrucBuffFromHandle(float3, meshData.positionBuffer)
    const float3 vertPos = vertexPositions[0];
    #define vertexAttributes ByteBuffFromHandle(meshData.attributesBuffer)

    MeshletDescriptor m = StrucBuffFromHandle(MeshletDescriptor, meshData.meshletDescriptors)[groupID];
    #define meshletUniqueVertexIndices StrucBuffFromHandle(uint, meshData.meshletUniqueVertexIndices)
    #define meshletPrimitiveIndices StrucBuffFromHandle(uint, meshData.meshletPrimitiveIndices)

    SetMeshOutputCounts(m.vertexCount, m.primCount);

    if (threadID < m.primCount)
    {
        const uint primBaseU8Index = m.primBegin + threadID*3u;
        uint word = meshletPrimitiveIndices[primBaseU8Index >> 2u];
        const uint bitStartInWord0 = (primBaseU8Index << 3u) & 0b11111u;
        const uint bitsInWord0 = 32u - bitStartInWord0;
        // move relevant bytes into lowest bits
        word >>= bitStartInWord0;
        // mask unused bits
        word &= ~(0xFFFFFFFFu << bitsInWord0);
        // move relevant bytes from next word into upper bits
        word |= meshletPrimitiveIndices[(primBaseU8Index + 2) >> 2u] << bitsInWord0;

        tris[threadID] = uint3(
            (word)          & 0xFFu,
            (word >> 8u)    & 0xFFu,
            (word >> 16u)   & 0xFFu
        );
    }

    ConstantBuffer<RenderPassData> renderPassData = getRenderPassData();
    
    if (threadID < m.vertexCount)
    {
        uint vertexIndex = meshletUniqueVertexIndices[m.vertexBegin + threadID];

        const float4x4 projViewMatrix = renderPassData.drawCam.projView;

        VertexOut vsOut = (VertexOut)0;
        vsOut.instanceIndex = pushConstants.indexInInstanceBuffer;

        const float3 vertPos = vertexPositions[vertexIndex];
        float4 worldPos = mul(instanceInfo.transform, float4(vertPos,1.0));
        vsOut.posOut = mul(projViewMatrix, worldPos);    
        vsOut.vTexCoord = vertexAttributes.Load<float2>(vertexIndex * meshData.attribStride() + meshData.uvOffset(0));

        verts[threadID] = vsOut;
    }
}