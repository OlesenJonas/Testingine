#define NO_DEFAULT_PUSH_CONSTANTS
#include "../includes/Bindless/Setup.hlsl"
#include "../includes/GPUScene/Setup.hlsl"
#include "../includes/Culling.hlsl"

struct DrawMeshTasksIndirectCommand
{
    uint    x;
    uint    y;
    uint    z;
    uint  pad;
};
ENABLE_BINDLESS_BUFFER_ACCESS(DrawMeshTasksIndirectCommand)

DefinePushConstants(
    ResrcHandle< ConstantBuffer<RenderPassData> > renderPassData;
    ResrcHandle< RWStructuredBuffer<InstanceInfo> > unsortedInstancesBuffer;
    ResrcHandle< StructuredBuffer<MeshData> > meshDataBuffer;
    ResrcHandle< StructuredBuffer<uint> > batchIndicesBuffer;
    ResrcHandle< RWStructuredBuffer<uint> > perBatchElementCountBuffer;
    ResrcHandle< RWStructuredBuffer<DrawMeshTasksIndirectCommand> > indirectTaskCommandsBuffer;
    uint totalInstances;
);

[numthreads(32, 1, 1)]
void main(uint globalThreadID : SV_DispatchThreadID)
{
    if(globalThreadID >= pushConstants.totalInstances)
        return;
        
    uint batchIndex = pushConstants.batchIndicesBuffer.get()[globalThreadID];
    RWStructuredBuffer<uint> countBuffer = pushConstants.perBatchElementCountBuffer.get();

    RWStructuredBuffer<InstanceInfo> instanceBuffer = pushConstants.unsortedInstancesBuffer.get();
    const InstanceInfo instanceInfo = instanceBuffer[globalThreadID];
    //clear last frames visible bit from sphere radius!
    float4 boundingSphere = instanceInfo.boundingSphere;
    boundingSphere.w = asfloat( 0x7FFFFFFF & asuint(boundingSphere.w));
    // const float4 center = mul(instanceInfo.transform, float4(0,0,0,1));
    const float3 center = boundingSphere.xyz;

    ConstantBuffer<RenderPassData> renderPassData = pushConstants.renderPassData.get();
    const float4x4 m = renderPassData.mainCam.projView;

    bool visible = true;

    float4 frustumPlanes[6];
    getFrustumPlanes(m, frustumPlanes);
    [unroll]
    for(int i=0; i<6; i++)
    {
        const float distToPlane = dot(float4(center,1), frustumPlanes[i]);
        visible &= distToPlane > -boundingSphere.w;
    }
    visible = true;

    // use bounding spheres radius' sign bit to encode if instance is visible
    instanceBuffer[globalThreadID].boundingSphere = float4(
        boundingSphere.xyz,
        asfloat((uint(visible) << 31u) | asuint(boundingSphere.w))
    );

    if(visible)
    {
        StructuredBuffer<MeshData> meshDataBuffer = pushConstants.meshDataBuffer.get();
        RWStructuredBuffer<DrawMeshTasksIndirectCommand> indirectCmdsBuffer = pushConstants.indirectTaskCommandsBuffer.get();
        indirectCmdsBuffer[batchIndex].x = 
            (meshDataBuffer[instanceBuffer[globalThreadID].meshDataIndex].meshletCount + 32 - 1) / 32;

        //todo consecutive instances likely share same index, so could try to use subgroup ops to reduce
        //     number of atomic calls needed!
        //  some combination of bitmask and findFirst?
        InterlockedAdd(countBuffer[batchIndex], 1);
    }
}