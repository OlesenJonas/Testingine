#version 460

#extension GL_GOOGLE_include_directive : require

#include "Bindless.glsl"

layout (push_constant, std430) uniform constants
{
    uint sourceTex;
    uint samplerIndex;
    uint targetTex;
};

//not bothering to use the bindless defines since next thing to work on is switching to HLSL anyways
layout (set = SAMPLED_IMG_SET, binding = GLOBAL_SAMPLER_COUNT) uniform texture2D global_texture2D[];
layout (set = STORAGE_IMG_SET, binding = 0, rgba32f) uniform writeonly restrict imageCube global_rgba32f_imageCube[];

const vec2 invAtan = vec2(0.1591, 0.3183);
vec2 sampleSphericalMap(vec3 v)
{
    vec2 uv = vec2(atan(v.z, v.x), -asin(v.y));
    uv *= invAtan;
    uv += 0.5;
    return uv;
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
    ivec3 id = ivec3(gl_GlobalInvocationID);

    ivec2 size = imageSize(global_rgba32f_imageCube[targetTex]);
    vec2 uv = vec2(id.xy + 0.5)/size;
    uv.y = 1.0-uv.y;
    uv = 2.0 * uv - 1.0;
    // uv = 2.0 * vec2(uv.x, 1.0-uv.y) - 1.0;

    vec3 localPos;
    if(id.z == 0)      localPos = vec3(  1.0, uv.y, -uv.x); // pos x
    else if(id.z == 1) localPos = vec3( -1.0, uv.y,  uv.x); // neg x
    else if(id.z == 2) localPos = vec3( uv.x,  1.0, -uv.y); // pos y
    else if(id.z == 3) localPos = vec3( uv.x, -1.0,  uv.y); // neg y
    else if(id.z == 4) localPos = vec3( uv.x, uv.y,   1.0); // pos z
    else if(id.z == 5) localPos = vec3(-uv.x, uv.y,  -1.0); // neg z

    vec3 color = texture(
        sampler2D(global_texture2D[sourceTex],Samplers[samplerIndex]), 
        sampleSphericalMap(normalize(localPos))
    ).xyz;

    imageStore(global_rgba32f_imageCube[targetTex], id, vec4(color, 1.0));
}